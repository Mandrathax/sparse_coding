\documentclass[a4paper, titlepage]{article}
\usepackage[sectionmark,fancysections]{polytechnique}
\usepackage[latin1]{inputenc}
\usepackage[cyr]{aeguill}
\usepackage[francais]{babel}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[]{algorithm2e}

\renewcommand{\vec}[1]{\mathbf{#1}}


\title{INF 552\\Image et vision par ordinateur}
%\subtitle{Projet : Reconstruction d'images par apprentissage}
\date{17 Janvier 2016}
\author{Paul Michel\\Antoine Prouvost\\Élèves en troisième année}

\begin{document}
\maketitle

\tableofcontents

\cleardoublepage
\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Nos motivations pour ce projet étaient de pouvoir implementer un algorithme d'apprentissage avec une vraie application au traitement des images.

Nous avons rapidement trouvé des travaux de recherche de l'Inria ainsi qu'un cours qui s'intéressaient à ce sujet \cite{ref1}. L'idée qui nous a tout de suite plu était de pouvoir reconstruire des images bruitées, partiellement détruites ou marquées. Sur la figure \ref{mot}, nous montrons les résultats des recherches de l'Inria \cite{ref1} qui nous ont motivés.

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.55]{./img/motivation.jpg} 
	\end{center}
	\caption{Motivation : résultats des méthodes de l'Inria\cite{ref1}}
	\label{mot}
\end{figure}

Le fonctionnement de l'algorithme consiste à apprendre un dictionnaire de sous images, appelés "patches", de l'image initiale ;  puis, d'utiliser celui-ci pour reconstruire chaque patche. La figure \ref{dic} montre un exemple de dictionnaire obtenu par l'Inria \cite{ref1}. On peut y apercevoir des "features" de l'image.

\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=0.55]{./img/dic.jpg} 
	\end{center}
	\caption{Exemple de dictionnaire obtenu par l'Inria \cite{ref1}}
	\label{dic}
\end{figure}

\cleardoublepage
\section{Algorithme et références}
		Nous utilisons essentiellement l'algorithme proposé dans \cite{ref2}, en appliquant quelques optimisations (utilisation de plusieurs patches à chaque itération, renouvellement des éléments du dictionnaires (atomes) nuls...
	\subsection{Dictionary Learning}
	
	Nous commençons par extraire l'ensemble des patches de l'image. Un patch est représenté ici comme un vecteur $\vec{x} \in \mathbb{R}^{m}$ où $m \in \mathbb{N}^{*}$ est la taille constante des patches (son nombre de pixels). Le dictionnaire, dont nous fixons la taille  $k \in \mathbb{N}^{*}$ est quant à lui représenté par une matrice $\vec{D} \in \mathbb{R}^{m*k}$. Les éléments du dictionnaire sont stockés en colones.\\
	
	\begin{algorithm}[H]
 		\KwData{$\lambda \in \mathbb{R}$, facteur de régularisation\\
		$T \in \mathbb{N}$, nombre d'itération de l'algorithme}
 		\KwResult{Un dictionnaire $\vec{D} \in \mathbb{R}^{m*k}$}
 		Remplir le dictionnaire initial $\vec{D}$ aléatoirement (une amélioration est d'utiliser des vecteurs propres de la matrice des patches : non implémenté)\;
		Initialiser deux matrices $\vec{A} \in \mathbb{R}^{m*m}$ et $\vec{B} \in \mathbb{R}^{m*k}$ à $0$\;
 		\For{$t=1$ to $T$}{
 		 	Tirer aléatoirement un (ou plusieurs) patche $\vec{x} \in \mathbb{R}^{m}$ dans l'ensemble des patches\;
			Calculer :$$\alpha = \arg \min_{\alpha \in  \mathbb{R}^{m}} \frac{1}{2}\parallel \vec{x} - \vec{D}*\vec{\alpha}\parallel_{2}^{2} + \lambda\parallel \vec{\alpha} \parallel_{1} $$à l'aide de LARS\;
			$A = A + \alpha\alpha^{T}$\;
			$B = B + \vec{x}\alpha^{T}$\;
			\For{$j=1$ to $k$}{
				$\vec{u} = \frac{1}{\vec{A}_{j,j}}(\vec{b}_{j} - \vec{D}\vec{a}_{j})$\;
				\If{$\vec{u}$ trop proche de $0$}{
					Réinitialiser $\vec{u}$ de façon aléatoire 
				}
				$\vec{d}_{j} = \frac{1}{\parallel\vec{u}\parallel_{2}}$\;
			}
	 	}
		 \Return D\;
 \caption{Online dictionary learning}
 \label{algo1}
\end{algorithm}

		Nous n'avons pas pu implémenter toutes les optimisations de l'algorithme en C++. Tout est cependant implémenté en python.
	\subsection{Reconstruction d'image}
		Pour reconstruire l'image, nous utilisons l'agorithme d'orthogonal matching pursuit (OPM) \cite{ref3}. La méthode proposée consiste à minimiser l'énergie une fois le dictionnaire fixé. Pour $k >0$ fixé, on s'intéresse pour chaque patch $\vec{x} \in \mathbb{R}^{m}$ (précédemment centré) à : $$\min_{\alpha \in \mathbb{R}^{k}} \parallel \vec{x} - \vec{D}\alpha\parallel_{2}^{2} S.C. \parallel\alpha\parallel_{0} < k$$
		

\cleardoublepage
\section{Implementation, résultats et interprétation}
	
	\subsection{C++}
		Pour notre implementation en C++, nous avons initialement décidé de travailler avec la bibliothèque \emph{CImg}. Celle-ci est plus simple d'utilisation que \emph{OpenCV} et s'inclue en un simple fichier .h. Finalement, cette bibliothèque ne a servi qu'à ouvrir et afficher les images.
		\\
		
		Nous n'avons pas implementer nous même la la méthode LARS utilisé dans l'algorithme. Pour cela, nous avons fait appel à la librairie \emph{MlPack} qui travaille avec les matrices et l'algèbre linéaire de la librairie \emph{Armadillo}. Nous avons donc travaillé avec ces objets pour notre algorithme.
		\\
		
		Malheureusement, nous n'avons pas réussi à présent à faire converger l'algorithme \ref{algo1} en C++ et obtenons des résultats décevants sans avoir pu en trouver l'origine. Le code C++ se trouve dans le répertoire "src" de notre projet.
		
		Sur l'image \ref{C}, nous pouvons observer de gauche à droite : l'image initiale avec un bruit gaussien, le dictionnaire initiale de patches $5*5$ et le dictionnaire final après l'algorithme. Quelques patches ont été encadrés en rouge pour en montrer leur représentation sur l'image.
		\begin{figure}[!h]
			\begin{center}
				\includegraphics[scale=0.3]{./img/C_result.jpg} 
			\end{center}
			\caption{Résultats de l'implementation C++}
			\label{C}
		\end{figure}
\clearpage
\subsection{Python}
		Devant les difficultés que nous avons rencontré en C++, nous avons rapidement décidé de réaliser un prototype en python afin de repérer nos erreurs. Les avantages de l'utilisation de python était la simplicité à installer et utiliser des librairies d'optimisation (dont l'implémentation sortait du cadre de notre projet), ainsi que la rapidité d'implémentation.
		
		Il a été fait usage des packages numpy (pour des opérations plus efficaces sur les tableaux), scipy et PIL (pour la conversion image/tableau) et scikit-learn (pour l'optimisation LARS lasso et OMP).
		
		Les résultats obtenus sont légèrement plus convaincants:
		\begin{figure}[!h]
			\begin{center}
				\includegraphics[scale=0.45]{./img/python_result.png} 
			\end{center}
			\caption{Résultats de l'implementation python (image originale, reconstruite et dictionnaire)}
		\end{figure}
		Cependant, l'image obtenue après reconstitution est plus floue. Nous pensons que ces problèmes sont en partie lié au fait que les images de base étant déjà petite et donc peu précises, il est difficile de distinguer le bruit de l'image originale. Nous ne disposions malheureusement pas du matériel nécessaire pour faire tourner notre programme sur des images plus grosses (nous sommes restés en dessous du $400\times 400$ pixels.
		
		Notre code python est trouvable dans le répertoire /python de notre dépôt git. Les packages nécessaires pour le faire tourner sont inclus dans beaucoup de distributions python scientifiques (anaconda pour ne citer qu'elle).
		
\cleardoublepage
\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}
		Bien que nous nous soyons heurtés à des difficultés d'implémentation, en raison notamment d'une dépendance importante envers des librairies d'optimisation, nous avons néanmoins obtenus des résultats satisfaisants sur notre implémentation python : les dictionnaires obtenus sont cohérents.
		Pour poursuivre notre projet nous envisageons, maintenant que notre implémentation est fonctionnelle, de la transposer en C++.
		Certaines améliorations peuvent être apportées à l'algorithme. Par exemple, lors de l'apprentissage du dictionnaire, certains "atomes" restent nuls ou aléatoires. On peut imaginer les éliminer en n'acceptant par exemple que les atomes ayant une entropie sous un certain niveau afin de maximiser l'information obtenue.

\cleardoublepage
\bibliographystyle{plain}
\addcontentsline{toc}{section}{References}
\bibliography{biblio}
\end{document}
